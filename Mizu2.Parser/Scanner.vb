' Generated by TinyPG v1.3 available at www.codeproject.com

Imports System
Imports System.Collections.Generic
Imports System.Text.RegularExpressions
Imports System.Xml.Serialization


Namespace Mizu.Parser
#Region "Scanner"

    Partial Public Class Scanner
        Public Input As String
        Public StartPos As Integer = 0
        Public EndPos As Integer = 0
        Public CurrentLine As Integer
        Public CurrentColumn As Integer
        Public CurrentPosition As Integer
        Public Skipped As List(Of Token) ' tokens that were skipped
        Public Patterns As Dictionary(Of TokenType, Regex)

        Private LookAheadToken As Token
        Private Tokens As List(Of TokenType)
        Private SkipList As List(Of TokenType) ' tokens to be skipped

        Public Sub New()
            Dim regex As Regex
            Patterns = New Dictionary(Of TokenType, Regex)()
            Tokens = New List(Of TokenType)()
            LookAheadToken = Nothing
            Skipped = New List(Of Token)()

            SkipList = New List(Of TokenType)()

            regex = new Regex("\<", RegexOptions.Compiled)
            Patterns.Add(TokenType.GT, regex)
            Tokens.Add(TokenType.GT)

            regex = new Regex("\<\=", RegexOptions.Compiled)
            Patterns.Add(TokenType.GTE, regex)
            Tokens.Add(TokenType.GTE)

            regex = new Regex("\=\=", RegexOptions.Compiled)
            Patterns.Add(TokenType.DEQUAL, regex)
            Tokens.Add(TokenType.DEQUAL)

            regex = new Regex("\>", RegexOptions.Compiled)
            Patterns.Add(TokenType.LT, regex)
            Tokens.Add(TokenType.LT)

            regex = new Regex("\>\=", RegexOptions.Compiled)
            Patterns.Add(TokenType.LTE, regex)
            Tokens.Add(TokenType.LTE)

            regex = new Regex("(\!\=|\<\>)", RegexOptions.Compiled)
            Patterns.Add(TokenType.NOTEQUAL, regex)
            Tokens.Add(TokenType.NOTEQUAL)

            regex = new Regex("\{", RegexOptions.Compiled)
            Patterns.Add(TokenType.OPENBRCK, regex)
            Tokens.Add(TokenType.OPENBRCK)

            regex = new Regex("\}", RegexOptions.Compiled)
            Patterns.Add(TokenType.CLOSEBRCK, regex)
            Tokens.Add(TokenType.CLOSEBRCK)

            regex = new Regex("\"".+?\""", RegexOptions.Compiled)
            Patterns.Add(TokenType.STRING, regex)
            Tokens.Add(TokenType.STRING)

            regex = new Regex("\,", RegexOptions.Compiled)
            Patterns.Add(TokenType.COMMA, regex)
            Tokens.Add(TokenType.COMMA)

            regex = new Regex("(\r\n|\n)", RegexOptions.Compiled)
            Patterns.Add(TokenType.NEWLINE, regex)
            Tokens.Add(TokenType.NEWLINE)

            regex = new Regex("\=", RegexOptions.Compiled)
            Patterns.Add(TokenType.EQUAL, regex)
            Tokens.Add(TokenType.EQUAL)

            regex = new Regex("\s+", RegexOptions.Compiled)
            Patterns.Add(TokenType.WHITESPACE, regex)
            Tokens.Add(TokenType.WHITESPACE)

            regex = new Regex("\[", RegexOptions.Compiled)
            Patterns.Add(TokenType.OPENBR, regex)
            Tokens.Add(TokenType.OPENBR)

            regex = new Regex("\]", RegexOptions.Compiled)
            Patterns.Add(TokenType.CLOSEBR, regex)
            Tokens.Add(TokenType.CLOSEBR)

            regex = new Regex("\:", RegexOptions.Compiled)
            Patterns.Add(TokenType.COLON, regex)
            Tokens.Add(TokenType.COLON)

            regex = new Regex("^\s*$", RegexOptions.Compiled)
            Patterns.Add(TokenType.EOF, regex)
            Tokens.Add(TokenType.EOF)

            regex = new Regex("\t", RegexOptions.Compiled)
            Patterns.Add(TokenType.TAB, regex)
            Tokens.Add(TokenType.TAB)

            regex = new Regex("\s\s\s\s", RegexOptions.Compiled)
            Patterns.Add(TokenType.FOURSPACE, regex)
            Tokens.Add(TokenType.FOURSPACE)

            regex = new Regex("[a-zA-Z_][a-zA-Z0-9_]*", RegexOptions.Compiled)
            Patterns.Add(TokenType.IDENTIFIER, regex)
            Tokens.Add(TokenType.IDENTIFIER)

            regex = new Regex("(\-)?[0-9]+", RegexOptions.Compiled)
            Patterns.Add(TokenType.NUMBER, regex)
            Tokens.Add(TokenType.NUMBER)

            regex = new Regex("(\-)?[0-9]+\.[0-9]+", RegexOptions.Compiled)
            Patterns.Add(TokenType.FLOAT, regex)
            Tokens.Add(TokenType.FLOAT)

            regex = new Regex("(null|nil)", RegexOptions.Compiled)
            Patterns.Add(TokenType.NULLKW, regex)
            Tokens.Add(TokenType.NULLKW)

            regex = new Regex("class", RegexOptions.Compiled)
            Patterns.Add(TokenType.CLASSKW, regex)
            Tokens.Add(TokenType.CLASSKW)

            regex = new Regex("public", RegexOptions.Compiled)
            Patterns.Add(TokenType.PUBLICKW, regex)
            Tokens.Add(TokenType.PUBLICKW)

            regex = new Regex("private", RegexOptions.Compiled)
            Patterns.Add(TokenType.PRIVATEKW, regex)
            Tokens.Add(TokenType.PRIVATEKW)

            regex = new Regex("(P|p)ublic class", RegexOptions.Compiled)
            Patterns.Add(TokenType.PUBLICCLASSKW, regex)
            Tokens.Add(TokenType.PUBLICCLASSKW)

            regex = new Regex("(P|p)rivate class", RegexOptions.Compiled)
            Patterns.Add(TokenType.PRIVATECLASSKW, regex)
            Tokens.Add(TokenType.PRIVATECLASSKW)

            regex = new Regex("def", RegexOptions.Compiled)
            Patterns.Add(TokenType.DEFKW, regex)
            Tokens.Add(TokenType.DEFKW)

            regex = new Regex("(P|p)ublic def", RegexOptions.Compiled)
            Patterns.Add(TokenType.PUBLICDEFKW, regex)
            Tokens.Add(TokenType.PUBLICDEFKW)

            regex = new Regex("(P|p)rivate def", RegexOptions.Compiled)
            Patterns.Add(TokenType.PRIVATEDEFKW, regex)
            Tokens.Add(TokenType.PRIVATEDEFKW)

            regex = new Regex("\(", RegexOptions.Compiled)
            Patterns.Add(TokenType.BROPEN, regex)
            Tokens.Add(TokenType.BROPEN)

            regex = new Regex("\)", RegexOptions.Compiled)
            Patterns.Add(TokenType.BRCLOSE, regex)
            Tokens.Add(TokenType.BRCLOSE)

            regex = new Regex("if", RegexOptions.Compiled)
            Patterns.Add(TokenType.IFKW, regex)
            Tokens.Add(TokenType.IFKW)

            regex = new Regex("true", RegexOptions.Compiled)
            Patterns.Add(TokenType.TRUE, regex)
            Tokens.Add(TokenType.TRUE)

            regex = new Regex("false", RegexOptions.Compiled)
            Patterns.Add(TokenType.FALSE, regex)
            Tokens.Add(TokenType.FALSE)

            regex = new Regex("var", RegexOptions.Compiled)
            Patterns.Add(TokenType.VAR, regex)
            Tokens.Add(TokenType.VAR)

            regex = new Regex("new", RegexOptions.Compiled)
            Patterns.Add(TokenType.NEW, regex)
            Tokens.Add(TokenType.NEW)

            regex = new Regex("as", RegexOptions.Compiled)
            Patterns.Add(TokenType.AS, regex)
            Tokens.Add(TokenType.AS)



        End Sub

        Public Sub Init(ByVal input As String)
            Me.Input = input
            StartPos = 0
            EndPos = 0
            CurrentLine = 0
            CurrentColumn = 0
            CurrentPosition = 0
            Skipped = New List(Of Token)()
            LookAheadToken = Nothing
        End Sub

        Public Function GetToken(ByVal type As TokenType) As Token
            Dim t As New Token(Me.StartPos, Me.EndPos)
            t.Type = type
            Return t
        End Function

        ''' <summary>
        ''' executes a lookahead of the next token
        ''' and will advance the scan on the input string
        ''' </summary>
        ''' <returns></returns>
        Public Function Scan(ByVal ParamArray expectedtokens As TokenType()) As Token
            Dim tok As Token = LookAhead(expectedtokens)
            ' temporarely retrieve the lookahead
            LookAheadToken = Nothing
            ' reset lookahead token, so scanning will continue
            StartPos = tok.EndPos
            EndPos = tok.EndPos
            ' set the tokenizer to the new scan position
            Return tok
        End Function

        ''' <summary>
        ''' returns token with longest best match
        ''' </summary>
        ''' <returns></returns>
        Public Function LookAhead(ByVal ParamArray expectedtokens As TokenType()) As Token
            Dim i As Integer
            Dim start As Integer = StartPos
            Dim tok As Token = Nothing
            Dim scantokens As List(Of TokenType)

            ' this prevents double scanning and matching
            ' increased performance
            If LookAheadToken IsNot Nothing AndAlso LookAheadToken.Type <> TokenType._UNDETERMINED_ AndAlso LookAheadToken.Type <> TokenType._NONE_ Then
                Return LookAheadToken
            End If

            If expectedtokens.Length = 0 Then
                scantokens = Tokens
            Else
                scantokens = New List(Of TokenType)(expectedtokens)
                scantokens.AddRange(SkipList)
            End If

            Do
                Dim len As Integer = -1
                Dim index As TokenType = Integer.MaxValue
                Dim m_input As String = Input.Substring(start)

                tok = New Token(start, EndPos)


                For i = 0 To scantokens.Count - 1
                    Dim r As Regex = Patterns(scantokens(i))
                    Dim m As Match = r.Match(m_input)
                    If m.Success AndAlso m.Index = 0 AndAlso ((m.Length > len) OrElse (scantokens(i) < index AndAlso m.Length = len)) Then
                        len = m.Length
                        index = scantokens(i)
                    End If
                Next i

                If index >= 0 AndAlso len >= 0 Then
                    tok.EndPos = start + len
                    tok.Text = Input.Substring(tok.StartPos, len)
                    tok.Type = index
                Else
                    If tok.StartPos < tok.EndPos - 1 Then
                        tok.Text = Input.Substring(tok.StartPos, 1)
                    End If
                End If

                If SkipList.Contains(tok.Type) Then
                    start = tok.EndPos
                    Skipped.Add(tok)
                Else
                    tok.Skipped = Skipped
                    Skipped = New List(Of Token)
                End If
            Loop While SkipList.Contains(tok.Type)

            LookAheadToken = tok
            Return tok
        End Function
    End Class
#End Region

#Region "Token"

    Public Enum TokenType

        'Non terminal tokens:
        _NONE_      = 0
        _UNDETERMINED_= 1

        'Non terminal tokens:
        Start       = 2
        Indention   = 3
        Boolean     = 4
        Assignment  = 5
        VariableAssignment= 6
        VariableExpr= 7
        Field       = 8
        Statement   = 9
        IndentedStatement= 10
        Method      = 11
        IfStatement = 12

        'Terminal tokens:
        GT          = 13
        GTE         = 14
        DEQUAL      = 15
        LT          = 16
        LTE         = 17
        NOTEQUAL    = 18
        OPENBRCK    = 19
        CLOSEBRCK   = 20
        STRING      = 21
        COMMA       = 22
        NEWLINE     = 23
        EQUAL       = 24
        WHITESPACE  = 25
        OPENBR      = 26
        CLOSEBR     = 27
        COLON       = 28
        EOF         = 29
        TAB         = 30
        FOURSPACE   = 31
        IDENTIFIER  = 32
        NUMBER      = 33
        FLOAT       = 34
        NULLKW      = 35
        CLASSKW     = 36
        PUBLICKW    = 37
        PRIVATEKW   = 38
        PUBLICCLASSKW= 39
        PRIVATECLASSKW= 40
        DEFKW       = 41
        PUBLICDEFKW = 42
        PRIVATEDEFKW= 43
        BROPEN      = 44
        BRCLOSE     = 45
        IFKW        = 46
        TRUE        = 47
        FALSE       = 48
        VAR         = 49
        NEW         = 50
        AS          = 51
    End Enum

    Public Class Token 
        Private m_startPos As Integer
        Private m_endPos As Integer
        Private m_text As String
        Private m_value As Object

        ' contains all prior skipped symbols
        Private m_skipped As List(Of Token)


        Public Property StartPos() As Integer
            Get
                Return m_startPos
            End Get
            Set(ByVal value As Integer)
                m_startPos = value
            End Set
        End Property

        Public Property EndPos() As Integer
            Get
                Return m_endPos
            End Get
            Set(ByVal value As Integer)
                m_endPos = value
            End Set
        End Property

        Public ReadOnly Property Length() As Integer
            Get
                Return m_endPos - m_startPos
            End Get
        End Property

        Public Property Text() As String
            Get
                Return m_text
            End Get
            Set(ByVal value As String)
                m_text = value
            End Set
        End Property

        Public Property Skipped() As List(Of Token)
            Get
                Return m_skipped
            End Get
            Set(ByVal value As List(Of Token))
                m_skipped = value
            End Set
        End Property

        Public Property Value() As Object
            Get
                Return m_value
            End Get
            Set(ByVal value As Object)
                Me.m_value = value
            End Set
        End Property

        <XmlAttribute()> _
        Public Type As TokenType

        Public Sub New()
            Me.New(0, 0)
        End Sub

        Public Sub New(ByVal start As Integer, ByVal endPos As Integer)
            Type = TokenType._UNDETERMINED_
            m_startPos = start
            m_endPos = endPos
            Text = ""
            ' must initialize with empty string, may cause null reference exceptions otherwise
            Value = Nothing
        End Sub

        Public Sub UpdateRange(ByVal token As Token)
            If token.StartPos < m_startPos Then
                m_startPos = token.StartPos
            End If
            If token.EndPos > m_endPos Then
                m_endPos = token.EndPos
            End If
        End Sub

        Public Overloads Overrides Function ToString() As String
            If Text <> Nothing Then
                Return Type.ToString() + " '" + Text + "'"
            Else
                Return Type.ToString()
            End If
        End Function
    End Class
#End Region
End Namespace
