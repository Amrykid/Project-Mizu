// Generated by TinyPG v1.2 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Mizu3.Parser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.HASH);
            while (tok.Type == TokenType.HASH)
            {
                ParsePragmaStatement(node);
            tok = scanner.LookAhead(TokenType.HASH);
            }

            
            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.LET
                || tok.Type == TokenType.IMPORT
                || tok.Type == TokenType.OUT
                || tok.Type == TokenType.TRY
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseStatements(node);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            if (tok.Type != TokenType.EOF)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatements(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statements), "Statements");
            parent.Nodes.Add(node);

            do {
                ParseStatement(node);
                tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            } while (tok.Type == TokenType.LET
                || tok.Type == TokenType.IMPORT
                || tok.Type == TokenType.OUT
                || tok.Type == TokenType.TRY
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.LET:
                    ParseLetStatement(node);
                    break;
                case TokenType.IMPORT:
                    ParseImportStatement(node);
                    break;
                case TokenType.OUT:
                    ParseOutStatement(node);
                    break;
                case TokenType.TRY:
                    ParseTryCatchStatement(node);
                    break;
                case TokenType.RETURN:
                    ParseRetStatement(node);
                    break;
                case TokenType.WHILE:
                    ParseWhileStatement(node);
                    break;
                case TokenType.BREAK:
                    ParseBreakStatement(node);
                    break;
                case TokenType.TYPE:
                    ParseFuncCallStatement(node);
                    break;
                case TokenType.IDENTIFIER:
                    ParseVariableReassignmentStatement(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseImportStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ImportStatement), "ImportStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IMPORT);
            if (tok.Type != TokenType.IMPORT)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IMPORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.TYPE);
            if (tok.Type != TokenType.TYPE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.FROM);
            if (tok.Type == TokenType.FROM)
            {

                
                tok = scanner.Scan(TokenType.FROM);
                if (tok.Type != TokenType.FROM)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                
                tok = scanner.Scan(TokenType.STRING);
                if (tok.Type != TokenType.STRING)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariableReassignmentStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariableReassignmentStatement), "VariableReassignmentStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.OPENBR);
            if (tok.Type == TokenType.OPENBR)
            {
                ParseArrayIndexExpr(node);
            }

            
            tok = scanner.Scan(TokenType.EQUAL);
            if (tok.Type != TokenType.EQUAL)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER, TokenType.FUNC);
            switch (tok.Type)
            {
                case TokenType.STRING:
                case TokenType.NUMBER:
                case TokenType.TRUE:
                case TokenType.FALSE:
                case TokenType.FLOAT:
                case TokenType.IDENTIFIER:
                    ParseArgument(node);
                    break;
                case TokenType.FUNC:
                    ParseFuncStatement(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseLetStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.LetStatement), "LetStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LET);
            if (tok.Type != TokenType.LET)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.EQUAL);
            if (tok.Type != TokenType.EQUAL)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER, TokenType.ITER, TokenType.FUNC, TokenType.NEW, TokenType.OPENBR, TokenType.BROPEN, TokenType.PLUS, TokenType.MINUS, TokenType.MULTI, TokenType.DIV);
            switch (tok.Type)
            {
                case TokenType.STRING:
                case TokenType.NUMBER:
                case TokenType.TRUE:
                case TokenType.FALSE:
                case TokenType.FLOAT:
                case TokenType.IDENTIFIER:
                    ParseArgument(node);
                    break;
                case TokenType.ITER:
                    ParseIterStatement(node);
                    break;
                case TokenType.FUNC:
                    ParseFuncStatement(node);
                    break;
                case TokenType.NEW:
                    ParseObjectCreatetion(node);
                    break;
                case TokenType.OPENBR:
                    ParseArrayIndexExpr(node);
                    break;
                case TokenType.BROPEN:
                case TokenType.PLUS:
                case TokenType.MINUS:
                case TokenType.MULTI:
                case TokenType.DIV:
                    ParseMathExpr(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseIterStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.IterStatement), "IterStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ITER);
            if (tok.Type != TokenType.ITER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ITER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.OPENBR);
            if (tok.Type != TokenType.OPENBR)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                case TokenType.FLOAT:

                    
                    tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT);
                    switch (tok.Type)
                    {
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            if (tok.Type != TokenType.NUMBER)
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            break;
                        case TokenType.FLOAT:
                            tok = scanner.Scan(TokenType.FLOAT);
                            if (tok.Type != TokenType.FLOAT)
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.Scan(TokenType.COLON);
                    if (tok.Type != TokenType.COLON)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                    
                    tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT, TokenType.IDENTIFIER);
                    switch (tok.Type)
                    {
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            if (tok.Type != TokenType.NUMBER)
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            break;
                        case TokenType.FLOAT:
                            tok = scanner.Scan(TokenType.FLOAT);
                            if (tok.Type != TokenType.FLOAT)
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            break;
                        case TokenType.IDENTIFIER:
                            tok = scanner.Scan(TokenType.IDENTIFIER);
                            if (tok.Type != TokenType.IDENTIFIER)
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.CLOSEBR);
            if (tok.Type != TokenType.CLOSEBR)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.ARROW);
            if (tok.Type != TokenType.ARROW)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.TYPE, TokenType.BRCKOPEN);
            switch (tok.Type)
            {
                case TokenType.TYPE:
                    ParseFuncCall(node);
                    break;
                case TokenType.BRCKOPEN:

                    
                    tok = scanner.Scan(TokenType.BRCKOPEN);
                    if (tok.Type != TokenType.BRCKOPEN)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                    
                    ParseStatements(node);

                    
                    tok = scanner.Scan(TokenType.BRCKCLOSE);
                    if (tok.Type != TokenType.BRCKCLOSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFuncStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FuncStatement), "FuncStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FUNC);
            if (tok.Type != TokenType.FUNC)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BROPEN);
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.TYPE, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER)
            {

                
                ParseParameter(node);

                
                tok = scanner.LookAhead(TokenType.COMMA);
                while (tok.Type == TokenType.COMMA)
                {

                    
                    tok = scanner.Scan(TokenType.COMMA);
                    if (tok.Type != TokenType.COMMA)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                    
                    ParseParameter(node);
                tok = scanner.LookAhead(TokenType.COMMA);
                }
            }

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.ARROW);
            if (tok.Type != TokenType.ARROW)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER, TokenType.BRCKOPEN);
            switch (tok.Type)
            {
                case TokenType.LET:
                case TokenType.IMPORT:
                case TokenType.OUT:
                case TokenType.TRY:
                case TokenType.RETURN:
                case TokenType.WHILE:
                case TokenType.BREAK:
                case TokenType.TYPE:
                case TokenType.IDENTIFIER:
                    ParseStatement(node);
                    break;
                case TokenType.BRCKOPEN:

                    
                    tok = scanner.Scan(TokenType.BRCKOPEN);
                    if (tok.Type != TokenType.BRCKOPEN)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                    
                    ParseStatements(node);

                    
                    tok = scanner.Scan(TokenType.BRCKCLOSE);
                    if (tok.Type != TokenType.BRCKCLOSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTypeFuncDeclartion(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TypeFuncDeclartion), "TypeFuncDeclartion");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.EQUAL);
            if (tok.Type != TokenType.EQUAL)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            ParseFuncStatement(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRetStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.RetStatement), "RetStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RETURN);
            if (tok.Type != TokenType.RETURN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.STRING
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.TRUE
                || tok.Type == TokenType.FALSE
                || tok.Type == TokenType.FLOAT
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseArgument(node);
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseOutStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OutStatement), "OutStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.OUT);
            if (tok.Type != TokenType.OUT)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OUT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.STRING
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.TRUE
                || tok.Type == TokenType.FALSE
                || tok.Type == TokenType.FLOAT
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseArgument(node);
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePragmaStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PragmaStatement), "PragmaStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.HASH);
            if (tok.Type != TokenType.HASH)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HASH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.EQUAL);
            if (tok.Type == TokenType.EQUAL)
            {

                
                tok = scanner.Scan(TokenType.EQUAL);
                if (tok.Type != TokenType.EQUAL)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                
                tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER);
                switch (tok.Type)
                {
                    case TokenType.IDENTIFIER:
                        tok = scanner.Scan(TokenType.IDENTIFIER);
                        if (tok.Type != TokenType.IDENTIFIER)
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        break;
                    case TokenType.NUMBER:
                        tok = scanner.Scan(TokenType.NUMBER);
                        if (tok.Type != TokenType.NUMBER)
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTryCatchStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TryCatchStatement), "TryCatchStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TRY);
            if (tok.Type != TokenType.TRY)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BRCKOPEN);
            if (tok.Type != TokenType.BRCKOPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.LET
                || tok.Type == TokenType.IMPORT
                || tok.Type == TokenType.OUT
                || tok.Type == TokenType.TRY
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseStatements(node);
            }

            
            tok = scanner.Scan(TokenType.BRCKCLOSE);
            if (tok.Type != TokenType.BRCKCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.CATCH);
            if (tok.Type != TokenType.CATCH)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CATCH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BROPEN);
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            ParseParameter(node);

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BRCKOPEN);
            if (tok.Type != TokenType.BRCKOPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.LET
                || tok.Type == TokenType.IMPORT
                || tok.Type == TokenType.OUT
                || tok.Type == TokenType.TRY
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseStatements(node);
            }

            
            tok = scanner.Scan(TokenType.BRCKCLOSE);
            if (tok.Type != TokenType.BRCKCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFuncCallStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FuncCallStatement), "FuncCallStatement");
            parent.Nodes.Add(node);


            
            ParseFuncCall(node);

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseWhileStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WhileStatement), "WhileStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WHILE);
            if (tok.Type != TokenType.WHILE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHILE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BROPEN);
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            ParseExpr(node);

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BRCKOPEN);
            if (tok.Type != TokenType.BRCKOPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKOPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.LET, TokenType.IMPORT, TokenType.OUT, TokenType.TRY, TokenType.RETURN, TokenType.WHILE, TokenType.BREAK, TokenType.TYPE, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.LET
                || tok.Type == TokenType.IMPORT
                || tok.Type == TokenType.OUT
                || tok.Type == TokenType.TRY
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.WHILE
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.TYPE
                || tok.Type == TokenType.IDENTIFIER)
            {
                ParseStatements(node);
            }

            
            tok = scanner.Scan(TokenType.BRCKCLOSE);
            if (tok.Type != TokenType.BRCKCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCKCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseBreakStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BreakStatement), "BreakStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BREAK);
            if (tok.Type != TokenType.BREAK)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BREAK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            if (tok.Type != TokenType.SEMICOLON)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expr), "Expr");
            parent.Nodes.Add(node);


            
            ParseArgument(node);

            
            tok = scanner.LookAhead(TokenType.GT, TokenType.LT, TokenType.LTE, TokenType.GTE, TokenType.EQUAL, TokenType.NOTEQUAL);
            switch (tok.Type)
            {
                case TokenType.GT:
                    tok = scanner.Scan(TokenType.GT);
                    if (tok.Type != TokenType.GT)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.LT:
                    tok = scanner.Scan(TokenType.LT);
                    if (tok.Type != TokenType.LT)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.LTE:
                    tok = scanner.Scan(TokenType.LTE);
                    if (tok.Type != TokenType.LTE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.GTE:
                    tok = scanner.Scan(TokenType.GTE);
                    if (tok.Type != TokenType.GTE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.EQUAL:
                    tok = scanner.Scan(TokenType.EQUAL);
                    if (tok.Type != TokenType.EQUAL)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.NOTEQUAL:
                    tok = scanner.Scan(TokenType.NOTEQUAL);
                    if (tok.Type != TokenType.NOTEQUAL)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOTEQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            ParseArgument(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParameter(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Parameter), "Parameter");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.TYPE);
            if (tok.Type == TokenType.TYPE)
            {

                
                tok = scanner.Scan(TokenType.TYPE);
                if (tok.Type != TokenType.TYPE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);

                
                tok = scanner.Scan(TokenType.COLON);
                if (tok.Type != TokenType.COLON)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            if (tok.Type != TokenType.IDENTIFIER)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArgument(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Argument), "Argument");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    if (tok.Type != TokenType.STRING)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    if (tok.Type != TokenType.NUMBER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.TRUE:
                case TokenType.FALSE:
                    ParseBoolean(node);
                    break;
                case TokenType.FLOAT:
                    tok = scanner.Scan(TokenType.FLOAT);
                    if (tok.Type != TokenType.FLOAT)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.IDENTIFIER:

                    
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);

                    
                    tok = scanner.LookAhead(TokenType.OPENBR);
                    if (tok.Type == TokenType.OPENBR)
                    {
                        ParseArrayIndexExpr(node);
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFuncCall(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FuncCall), "FuncCall");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TYPE);
            if (tok.Type != TokenType.TYPE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.BROPEN);
            if (tok.Type != TokenType.BROPEN)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER);
            if (tok.Type == TokenType.STRING
                || tok.Type == TokenType.NUMBER
                || tok.Type == TokenType.TRUE
                || tok.Type == TokenType.FALSE
                || tok.Type == TokenType.FLOAT
                || tok.Type == TokenType.IDENTIFIER)
            {
                do {

                    
                    ParseArgument(node);

                    
                    tok = scanner.LookAhead(TokenType.COMMA);
                    if (tok.Type == TokenType.COMMA)
                    {
                        tok = scanner.Scan(TokenType.COMMA);
                        if (tok.Type != TokenType.COMMA)
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                    }
                    tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.TRUE, TokenType.FALSE, TokenType.FLOAT, TokenType.IDENTIFIER);
                } while (tok.Type == TokenType.STRING
                    || tok.Type == TokenType.NUMBER
                    || tok.Type == TokenType.TRUE
                    || tok.Type == TokenType.FALSE
                    || tok.Type == TokenType.FLOAT
                    || tok.Type == TokenType.IDENTIFIER);
            }

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            if (tok.Type != TokenType.BRCLOSE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArrayIndexExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ArrayIndexExpr), "ArrayIndexExpr");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.OPENBR);
            if (tok.Type != TokenType.OPENBR)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.IDENTIFIER, TokenType.BROPEN, TokenType.PLUS, TokenType.MINUS, TokenType.MULTI, TokenType.DIV);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    if (tok.Type != TokenType.NUMBER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.BROPEN:
                case TokenType.PLUS:
                case TokenType.MINUS:
                case TokenType.MULTI:
                case TokenType.DIV:
                    ParseMathExpr(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.CLOSEBR);
            if (tok.Type != TokenType.CLOSEBR)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseObjectCreatetion(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ObjectCreatetion), "ObjectCreatetion");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.NEW);
            if (tok.Type != TokenType.NEW)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEW.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            
            tok = scanner.Scan(TokenType.TYPE);
            if (tok.Type != TokenType.TYPE)
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TYPE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseBoolean(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Boolean), "Boolean");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.TRUE, TokenType.FALSE);
            switch (tok.Type)
            {
                case TokenType.TRUE:
                    tok = scanner.Scan(TokenType.TRUE);
                    if (tok.Type != TokenType.TRUE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRUE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.FALSE:
                    tok = scanner.Scan(TokenType.FALSE);
                    if (tok.Type != TokenType.FALSE)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FALSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMathExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MathExpr), "MathExpr");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.BROPEN);
            if (tok.Type == TokenType.BROPEN)
            {
                tok = scanner.Scan(TokenType.BROPEN);
                if (tok.Type != TokenType.BROPEN)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

            
            ParseOPERATOR(node);

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.BROPEN, TokenType.PLUS, TokenType.MINUS, TokenType.MULTI, TokenType.DIV, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    if (tok.Type != TokenType.NUMBER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.BROPEN:
                case TokenType.PLUS:
                case TokenType.MINUS:
                case TokenType.MULTI:
                case TokenType.DIV:
                    ParseMathExpr(node);
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.BROPEN, TokenType.PLUS, TokenType.MINUS, TokenType.MULTI, TokenType.DIV, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    if (tok.Type != TokenType.NUMBER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.BROPEN:
                case TokenType.PLUS:
                case TokenType.MINUS:
                case TokenType.MULTI:
                case TokenType.DIV:
                    ParseMathExpr(node);
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    if (tok.Type != TokenType.IDENTIFIER)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.BRCLOSE);
            if (tok.Type == TokenType.BRCLOSE)
            {
                tok = scanner.Scan(TokenType.BRCLOSE);
                if (tok.Type != TokenType.BRCLOSE)
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseOPERATOR(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OPERATOR), "OPERATOR");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PLUS, TokenType.MINUS, TokenType.MULTI, TokenType.DIV);
            switch (tok.Type)
            {
                case TokenType.PLUS:
                    tok = scanner.Scan(TokenType.PLUS);
                    if (tok.Type != TokenType.PLUS)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.MINUS:
                    tok = scanner.Scan(TokenType.MINUS);
                    if (tok.Type != TokenType.MINUS)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.MULTI:
                    tok = scanner.Scan(TokenType.MULTI);
                    if (tok.Type != TokenType.MULTI)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTI.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                case TokenType.DIV:
                    tok = scanner.Scan(TokenType.DIV);
                    if (tok.Type != TokenType.DIV)
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
