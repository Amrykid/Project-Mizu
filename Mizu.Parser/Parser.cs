// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace Mizu.Parser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.QUESTION, TokenType.IDENTIFIER, TokenType.PERIOD, TokenType.ABS, TokenType.SIN, TokenType.TAN, TokenType.SQRT);
            if (tok.Type == TokenType.QUESTION
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.PERIOD
                || tok.Type == TokenType.ABS
                || tok.Type == TokenType.SIN
                || tok.Type == TokenType.TAN
                || tok.Type == TokenType.SQRT)
            {
                ParseStatements(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatements(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statements), "Statements");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.QUESTION, TokenType.IDENTIFIER, TokenType.PERIOD, TokenType.ABS, TokenType.SIN, TokenType.TAN, TokenType.SQRT);
            while (tok.Type == TokenType.QUESTION
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.PERIOD
                || tok.Type == TokenType.ABS
                || tok.Type == TokenType.SIN
                || tok.Type == TokenType.TAN
                || tok.Type == TokenType.SQRT)
            {
                ParseStatement(node);
            tok = scanner.LookAhead(TokenType.QUESTION, TokenType.IDENTIFIER, TokenType.PERIOD, TokenType.ABS, TokenType.SIN, TokenType.TAN, TokenType.SQRT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Statement), "Statement");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.QUESTION, TokenType.IDENTIFIER, TokenType.PERIOD, TokenType.ABS, TokenType.SIN, TokenType.TAN, TokenType.SQRT);
            switch (tok.Type)
            {
                case TokenType.QUESTION:
                    ParseEvalStatement(node);
                    break;
                case TokenType.IDENTIFIER:
                    ParseVarStatement(node);
                    break;
                case TokenType.PERIOD:
                    ParsePrintStatement(node);
                    break;
                case TokenType.ABS:
                case TokenType.SIN:
                case TokenType.TAN:
                case TokenType.SQRT:
                    ParseMathCMDStatement(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.EOF, TokenType.NEWLINE, TokenType.STATEMENTSEP);
            switch (tok.Type)
            {
                case TokenType.EOF:
                    tok = scanner.Scan(TokenType.EOF);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.EOF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NEWLINE:
                case TokenType.STATEMENTSEP:

                    
                    tok = scanner.LookAhead(TokenType.NEWLINE, TokenType.STATEMENTSEP);
                    switch (tok.Type)
                    {
                        case TokenType.NEWLINE:
                            do {
                                tok = scanner.Scan(TokenType.NEWLINE);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.NEWLINE) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NEWLINE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                tok = scanner.LookAhead(TokenType.NEWLINE);
                            } while (tok.Type == TokenType.NEWLINE);
                            break;
                        case TokenType.STATEMENTSEP:

                            
                            do {
                                tok = scanner.Scan(TokenType.STATEMENTSEP);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.STATEMENTSEP) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STATEMENTSEP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                tok = scanner.LookAhead(TokenType.STATEMENTSEP);
                            } while (tok.Type == TokenType.STATEMENTSEP);

                            
                            tok = scanner.LookAhead(TokenType.MULTINEWLINE);
                            if (tok.Type == TokenType.MULTINEWLINE)
                            {
                                tok = scanner.Scan(TokenType.MULTINEWLINE);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.MULTINEWLINE) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTINEWLINE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.LookAhead(TokenType.EOF);
                    if (tok.Type == TokenType.EOF)
                    {
                        tok = scanner.Scan(TokenType.EOF);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.EOF) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseEvalStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.EvalStatement), "EvalStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.QUESTION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.QUESTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUESTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COLON, TokenType.EQUAL);
            switch (tok.Type)
            {
                case TokenType.COLON:
                    tok = scanner.Scan(TokenType.COLON);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COLON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.EQUAL:
                    tok = scanner.Scan(TokenType.EQUAL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.EQUAL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            ParseAddExpr(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVarStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VarStatement), "VarStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.SET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT, TokenType.OPENBR, TokenType.UPPER);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                case TokenType.FLOAT:
                    tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT);
                    switch (tok.Type)
                    {
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NUMBER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.FLOAT:
                            tok = scanner.Scan(TokenType.FLOAT);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.FLOAT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }
                    break;
                case TokenType.OPENBR:

                    
                    tok = scanner.Scan(TokenType.OPENBR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OPENBR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPENBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.PERIOD, TokenType.COMMA);
                    switch (tok.Type)
                    {
                        case TokenType.PERIOD:

                            
                            tok = scanner.Scan(TokenType.PERIOD);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.PERIOD) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }

                            
                            tok = scanner.Scan(TokenType.PERIOD);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.PERIOD) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }

                            
                            tok = scanner.Scan(TokenType.NUMBER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NUMBER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.COMMA:
                            do {

                                
                                tok = scanner.Scan(TokenType.COMMA);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMMA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }

                                
                                tok = scanner.Scan(TokenType.NUMBER);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.NUMBER) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                tok = scanner.LookAhead(TokenType.COMMA);
                            } while (tok.Type == TokenType.COMMA);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.Scan(TokenType.CLOSEBR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CLOSEBR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLOSEBR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.UPPER:

                    
                    tok = scanner.Scan(TokenType.UPPER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.UPPER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UPPER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.WAVEY);
                    if (tok.Type == TokenType.WAVEY)
                    {
                        tok = scanner.Scan(TokenType.WAVEY);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.WAVEY) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAVEY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePrintStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PrintStatement), "PrintStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PERIOD);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PERIOD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.FLOAT, TokenType.PERIOD, TokenType.STRING, TokenType.SIN);
            switch (tok.Type)
            {
                case TokenType.IDENTIFIER:
                case TokenType.NUMBER:
                case TokenType.FLOAT:
                case TokenType.PERIOD:

                    
                    tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.FLOAT);
                    switch (tok.Type)
                    {
                        case TokenType.IDENTIFIER:
                            tok = scanner.LookAhead(TokenType.IDENTIFIER);
                            if (tok.Type == TokenType.IDENTIFIER)
                            {
                                tok = scanner.Scan(TokenType.IDENTIFIER);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.IDENTIFIER) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                            }
                            break;
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NUMBER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.FLOAT:
                            tok = scanner.Scan(TokenType.FLOAT);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.FLOAT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.LookAhead(TokenType.PERIOD);
                    if (tok.Type == TokenType.PERIOD)
                    {
                        tok = scanner.Scan(TokenType.PERIOD);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PERIOD) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    }
                    break;
                case TokenType.STRING:

                    
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.PERIOD);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PERIOD) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PERIOD.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SIN:

                    
                    tok = scanner.Scan(TokenType.SIN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SIN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.WHITESPACE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.WHITESPACE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    do {

                        
                        tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.FLOAT);
                        switch (tok.Type)
                        {
                            case TokenType.IDENTIFIER:
                                tok = scanner.Scan(TokenType.IDENTIFIER);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.IDENTIFIER) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.NUMBER:
                                tok = scanner.Scan(TokenType.NUMBER);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.NUMBER) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.FLOAT:
                                tok = scanner.Scan(TokenType.FLOAT);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.FLOAT) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                break;
                        }

                        
                        tok = scanner.LookAhead(TokenType.WHITESPACE);
                        if (tok.Type == TokenType.WHITESPACE)
                        {
                            tok = scanner.Scan(TokenType.WHITESPACE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.WHITESPACE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                        }
                        tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER, TokenType.FLOAT);
                    } while (tok.Type == TokenType.IDENTIFIER
                        || tok.Type == TokenType.NUMBER
                        || tok.Type == TokenType.FLOAT);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMathCMDStatement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MathCMDStatement), "MathCMDStatement");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.ABS, TokenType.SIN, TokenType.TAN, TokenType.SQRT);
            switch (tok.Type)
            {
                case TokenType.ABS:
                    tok = scanner.Scan(TokenType.ABS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ABS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ABS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SIN:
                    tok = scanner.Scan(TokenType.SIN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SIN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.TAN:
                    tok = scanner.Scan(TokenType.TAN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TAN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TAN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SQRT:
                    tok = scanner.Scan(TokenType.SQRT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SQRT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQRT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.BROPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BROPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.BRCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAddExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


            
            ParseMultExpr(node);

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            while (tok.Type == TokenType.PLUSMINUS)
            {

                
                tok = scanner.Scan(TokenType.PLUSMINUS);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseMultExpr(node);
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMultExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


            
            ParseAtom(node);

            
            tok = scanner.LookAhead(TokenType.MULTDIV);
            while (tok.Type == TokenType.MULTDIV)
            {

                
                tok = scanner.Scan(TokenType.MULTDIV);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MULTDIV) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseAtom(node);
            tok = scanner.LookAhead(TokenType.MULTDIV);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAtom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.FLOAT, TokenType.IDENTIFIER, TokenType.BROPEN);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.FLOAT:
                    tok = scanner.Scan(TokenType.FLOAT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FLOAT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FLOAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.BROPEN:

                    
                    tok = scanner.Scan(TokenType.BROPEN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BROPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BROPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }

                    
                    ParseAddExpr(node);

                    
                    tok = scanner.Scan(TokenType.BRCLOSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRCLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
